/*
小易去附近的商店买苹果，奸诈的商贩使用了捆绑交易，只提供6个每袋和8个每袋的包装(包装不可拆分)。
可是小易现在只想购买恰好n个苹果，小易想购买尽量少的袋数方便携带。如果不能购买恰好n个苹果，小易
将不会购买。
输入描述：
输入一个整数n，表示小易想购买n(1 ≤ n ≤ 100)个苹果
输出描述：
输出一个整数表示最少需要购买的袋数，如果不能买恰好n个苹果则输出-1

解题思路：

1.对数字特征进行分析。首先，6和8都是偶数。因此，能凑出的数也是偶数。那么程序中如果苹果总数是奇数时，可以直接返回-1；偶数个苹果数对8取模，其结果只可能为0，2，4，6。若余数为6或0，则可以直接用6个的包装处理或者不处理，不需要回溯；若余数为4，只需回溯1次即可，因为8+4=12，12%6=0；若余数为2，则需回溯两次，因为8+8+2=12，12%6=0。

2.（由于数字6和8的特征，本方法只适用于本题。）

情况一：若num不是偶数，则直接返回-1；

情况二：若num%8=0，则返回num/8；

情况三：若num%8！=0，则只需回溯1次或者2次8包装购买个数，就可以求解。回溯1次，其结果为num/8-1+2=num/8+1；回溯2次，其结果为num/8-2+3=num/8+1。


 */


import java.util.*;

public class Main{
    public static int Res(int x){
        while(x%2==0) {
            if(x%8==0){
                return x/8;
            }
            else {
                if(x%8==6){
                    return (x/8)+1;
                }
                else if(x%6==0) {
                    return x/6;
                }
                else if(x%8==4) {
                    if((x/8)%2==1){
                        return (x/8)+1;
                    }
                    else{
                        return -1;
                    }
                }
                else if(x%8==2) {
                    if((x/8)%2==0) {
                        return (x/8)+1;
                    }
                    else
                    {
                        return -1;
                    }
                }
            }
        }
        return -1;
    }
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        if(n>=1&&n<=100){
            System.out.println(Res(n));
        }
    }
}
